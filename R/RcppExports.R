# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Two-dimension Diffusion Model
#'
#' Density, random generation for the 2-D diffusion model.
#'
#' The model has the main parameters, v1, v2, eta1, eta2, a, sigma, and t0.
#' tmax, kmax, sz and nw are tuning parameters for determining the set.
#' dcircle300 produces PDF table and others.
#'
#' @param RT, a vector storing response times
#' @param A a vector storing response angles.
#' @param P is a parameter vector, c(v1, v2, a, t0, sigma1, sigma2, eta1, eta2).
#' The sequence is important. v1 is the x-axis mean drift rate. v2 is the
#' y-axis mean drift rate. sigma1 is the x-axis within-trial drift rate SD.
#' sigma2 is the y-axix within-trial drift rate SD. a is decision threshold.
#' sigma1 and sigma2 must be 1 and identical, because this is what has been
#' thoroughly tested so far. Other values may return unknown results. t0
#' non-decision time.
#' @param tmax maximum time of the model
#' @param kmax the tuning parameter for Bessel function. Mostly 50.
#' @param h,sz sz is the number of time steps (h = tmax / sz). h is time step.
#' Mostly .1 ms.
#' @param nw the number of theta steps (w = 2 * pi / nw)
#' @param n number of observations
#' @return rcircle returns a n x 2 matrix. Each row is an [RT R] trial.
#' dcircle returns a n vector.
#' @examples
#' ## TODO examples
#' @export
dcircle <- function(RT, A, P, tmax, kmax, sz, nw) {
    .Call('_ggdmc_dcircle', PACKAGE = 'ggdmc', RT, A, P, tmax, kmax, sz, nw)
}

#' @rdname dcircle
#' @export
dcircle300 <- function(P, tmax, kmax, sz, nw) {
    .Call('_ggdmc_dcircle300', PACKAGE = 'ggdmc', P, tmax, kmax, sz, nw)
}

#' @rdname dcircle
#' @export
rcircle <- function(n, P, tmax, h, nw) {
    .Call('_ggdmc_rcircle', PACKAGE = 'ggdmc', n, P, tmax, h, nw)
}

#' @rdname dcircle
#' @export
rcircle_process <- function(P, tmax, h) {
    .Call('_ggdmc_rcircle_process', PACKAGE = 'ggdmc', P, tmax, h)
}

#' One-dimension Diffusion decision process
#'
#' This function generates one 1-D diffusion process.
#'
#' The model has five parameters, v, a, z, t0, and s. tmax and h are
#' tuning parameters for determining the set.
#'
#' @param P is a parameter vector, c(v, a, z, t0, s).
#' The sequence must be followed. v is the drift rate
#' a is decision threshold. t0 is the non-decision time.
#' @param tmax maximum time allowed.
#' @param kmax the tuning parameter for Bessel function. Mostly 50.
#' @param h,sz sz is the number of time steps (h = tmax / sz). h is
#' the size of one time step. We usually set h = 1e-4. That is .1 ms.
#' So when tmax is 2 second and each time step is 0.1 ms, sz will be
#' 2e4 steps.
#' @return rcircle returns a n x 2 matrix. Each row is an [RT R] trial.
#' dcircle returns a n vector.
#' @examples
#'
#' @rdname dcircle
#' @export
r1d <- function(P, tmax, h) {
    .Call('_ggdmc_r1d', PACKAGE = 'ggdmc', P, tmax, h)
}

#' Calculate log likelihoods
#'
#' These function calculate log likelihoods. \code{likelihood_rd} implements
#' the equations in Voss, Rothermund, and Voss (2004). These equations
#' calculate diffusion decision model (Ratcliff & Mckoon, 2008). Specifically,
#' this function implements Voss, Rothermund, and Voss's (2004) equations A1
#' to A4 (page 1217) in C++.
#'
#' @param pvector a parameter vector
#' @param data data model instance
#' @param min_lik minimal likelihood.
#' @param precision a tuning parameter for the precision of DDM likelihood.
#' The larger the value is, the more precise the likelihood is and the slower
#' the computation would be.
#' @return a vector
#' @references Voss, A., Rothermund, K., & Voss, J. (2004).  Interpreting the
#' parameters of the diffusion model: An empirical validation.
#' \emph{Memory & Cognition}, \bold{32(7)}, 1206-1220. \cr\cr
#' Ratcliff, R. (1978). A theory of memory retrival. \emph{Psychological
#' Review}, \bold{85}, 238-255.
#'
#' @examples
#' model <- BuildModel(
#' p.map     = list(A = "1", B = "1", t0 = "1", mean_v = "M", sd_v = "1",
#'             st0 = "1"),
#' match.map = list(M = list(s1 = 1, s2 = 2)),
#' factors   = list(S = c("s1", "s2")),
#' constants = c(st0 = 0, sd_v = 1),
#' responses = c("r1", "r2"),
#' type      = "norm")
#'
#' p.vector <- c(A = .25, B = .35,  t0 = .2, mean_v.true = 1, mean_v.false = .25)
#' dat <- simulate(model, 1e3,  ps = p.vector)
#' dmi <- BuildDMI(dat, model)
#' den <- likelihood(p.vector, dmi)
#'
#' model <- BuildModel(
#' p.map     = list(a = "1", v = "1", z = "1", d = "1", t0 = "1", sv = "1",
#'             sz = "1", st0 = "1"),
#' constants = c(st0 = 0, d = 0),
#' match.map = list(M = list(s1 = "r1", s2 = "r2")),
#' factors   = list(S = c("s1", "s2")),
#' responses = c("r1", "r2"),
#' type      = "rd")
#'
#' p.vector <- c(a = 1, v = 1, z = 0.5, sz = 0.25, sv = 0.2, t0 = .15)
#' dat <- simulate(model, 1e2, ps = p.vector)
#' dmi <- BuildDMI(dat, model)
#' den <- likelihood (p.vector, dmi)
#'
#' @export
likelihood <- function(pvector, data, min_lik = 1e-10, precision = 3.0) {
    .Call('_ggdmc_likelihood', PACKAGE = 'ggdmc', pvector, data, min_lik, precision)
}

p_df <- function(pvector, cell, mtype, pnames, parnames, dim0, dim1, dim2, allpar, model, isr1, n1idx, n1order) {
    .Call('_ggdmc_p_df', PACKAGE = 'ggdmc', pvector, cell, mtype, pnames, parnames, dim0, dim1, dim2, allpar, model, isr1, n1idx, n1order)
}

ac_ <- function(x, nlag) {
    .Call('_ggdmc_ac_', PACKAGE = 'ggdmc', x, nlag)
}

trial_loglik <- function(samples, thin_pointwise) {
    .Call('_ggdmc_trial_loglik', PACKAGE = 'ggdmc', samples, thin_pointwise)
}

r_fastdm <- function(num_values, params, precision = 3, stop_on_error = TRUE) {
    .Call('_ggdmc_r_fastdm', PACKAGE = 'ggdmc', num_values, params, precision, stop_on_error)
}

p_fastdm <- function(rts, params, precision = 3, boundary = 2L, stop_on_error = TRUE) {
    .Call('_ggdmc_p_fastdm', PACKAGE = 'ggdmc', rts, params, precision, boundary, stop_on_error)
}

init_new <- function(dmi, prior, nchain, nmc, thin, report, rp, gammamult, pm, pm_old, block) {
    .Call('_ggdmc_init_new', PACKAGE = 'ggdmc', dmi, prior, nchain, nmc, thin, report, rp, gammamult, pm, pm_old, block)
}

init_old <- function(samples, nmc, thin, report, rp, gammamult, pm, pm_old, block, add) {
    .Call('_ggdmc_init_old', PACKAGE = 'ggdmc', samples, nmc, thin, report, rp, gammamult, pm, pm_old, block, add)
}

init_newhier <- function(prior, lprior, sprior, dmi, nchain, nmc, thin, report, rp, gammamult, pm, pm_old, block) {
    .Call('_ggdmc_init_newhier', PACKAGE = 'ggdmc', prior, lprior, sprior, dmi, nchain, nmc, thin, report, rp, gammamult, pm, pm_old, block)
}

init_oldhier <- function(samples, nmc, thin, report, rp, gammamult, pm, pm_old, block, add) {
    .Call('_ggdmc_init_oldhier', PACKAGE = 'ggdmc', samples, nmc, thin, report, rp, gammamult, pm, pm_old, block, add)
}

init_oldhier_from_fixed_model <- function(samples, lprior, sprior, nmc, thin, report, rp, gammamult, pm, pm_old, block, add) {
    .Call('_ggdmc_init_oldhier_from_fixed_model', PACKAGE = 'ggdmc', samples, lprior, sprior, nmc, thin, report, rp, gammamult, pm, pm_old, block, add)
}

timesTwo <- function(x) {
    .Call('_ggdmc_timesTwo', PACKAGE = 'ggdmc', x)
}

#' Generate Random Deviates of the LBA Distribution
#'
#' \code{rlba_norm}, only slightly faster than \code{maker}, calls C++
#' function directly.
#'
#' @param n is the numbers of observation.
#' @param A start point upper bound, a vector of a scalar.
#' @param b decision threshold, a vector or a scalar.
#' @param mean_v mean drift rate vector
#' @param sd_v standard deviation of drift rate vector
#' @param t0 nondecision time, a vector.
#' @param st0 nondecision time variation, a vector.
#' @param posdrift if exclude negative drift rates
#'
#' @return a n x 2 matrix of RTs (first column) and responses (second column).
#' @export
rlba_norm <- function(n, A, b, mean_v, sd_v, t0, st0, posdrift) {
    .Call('_ggdmc_rlba_norm', PACKAGE = 'ggdmc', n, A, b, mean_v, sd_v, t0, st0, posdrift)
}

rprior_mat <- function(prior, n) {
    .Call('_ggdmc_rprior_mat', PACKAGE = 'ggdmc', prior, n)
}

test_sumlogprior <- function(pvec, prior) {
    .Call('_ggdmc_test_sumlogprior', PACKAGE = 'ggdmc', pvec, prior)
}

test_dprior <- function(pvec, pprior) {
    .Call('_ggdmc_test_dprior', PACKAGE = 'ggdmc', pvec, pprior)
}

spdf <- function(x, RT, n, h_in, debug) {
    .Call('_ggdmc_spdf', PACKAGE = 'ggdmc', x, RT, n, h_in, debug)
}

#' Truncated Normal Distribution
#'
#' Random number generation, probability density and cumulative density
#' functions for truncated normal distribution.
#'
#' @param x,q vector of quantiles;
#' @param n number of observations. n must be a scalar.
#' @param p1 mean (must be scalar).
#' @param p2 standard deviation (must be scalar).
#' @param lower lower truncation value (must be scalar).
#' @param upper upper truncation value (must be scalar).
#' @param lt lower tail. If TRUE (default) probabilities are \code{P[X <= x]},
#' otherwise, \code{P[X > x]}.
#' @param lg log probability. If TRUE (default is FALSE) probabilities p are
#' given as \code{log(p)}.
#' @return a numeric vector.
#' @examples
#' ## rtnorm example
#' dat1 <- rtnorm(1e5, 0, 1, 0, Inf)
#' hist(dat1, breaks = "fd", freq = FALSE, xlab = "",
#'      main = "Truncated normal distributions")
#'
#' ## dtnorm example
#' x <- seq(-5, 5, length.out = 1e3)
#' dat1 <- dtnorm(x, 0, 1, -2, 2, 0)
#' plot(x, dat1, type = "l", lwd = 2, xlab = "", ylab= "Density",
#'      main = "Truncated normal distributions")
#'
#' ## ptnorm example
#' x <- seq(-10, 10, length.out = 1e2)
#' mean <- 0
#' sd <- 1
#' lower <- 0
#' upper <- 5
#' dat1 <- ptnorm(x, 0, 1, 0, 5, lg = TRUE)
#' @export
dtnorm <- function(x, p1, p2, lower, upper, lg = FALSE) {
    .Call('_ggdmc_dtnorm', PACKAGE = 'ggdmc', x, p1, p2, lower, upper, lg)
}

#' @rdname dtnorm
#' @export
rtnorm <- function(n, p1, p2, lower, upper) {
    .Call('_ggdmc_rtnorm', PACKAGE = 'ggdmc', n, p1, p2, lower, upper)
}

#' @rdname dtnorm
#' @export
ptnorm <- function(q, p1, p2, lower, upper, lt = TRUE, lg = FALSE) {
    .Call('_ggdmc_ptnorm', PACKAGE = 'ggdmc', q, p1, p2, lower, upper, lt, lg)
}

#' Generate random deviates from a von Mises distribution
#'
#' This function generates random numbers in radian unit from a von Mises
#' distribution using the location (ie mean) parameter, mu and the
#' concentration (ie precision) parameter kappa.
#'
#' A random number for a circular normal distribution has the form:\cr
#' \deqn{f(theta; mu, kappa) = 1 / (2*pi*I0(kappa)) * exp(kappa*cos(theta-mu))}
#' theta is between 0 and 2*pi.
#'
#' \code{I0(kappa)} in the normalizing constant is the modified Bessel
#' function of the first kind and order zero.
#'
#' @param x,q x and q are the quantiles. These must be one a scalar.
#' @param n number of observations
#' @param tol the tolerance imprecision for von Mist distribution function.
#' @param mu mean direction of the distribution. Must be a scalar.
#' @param kappa concentration parameter. A positive value
#' for the concentration parameter of the distribution. Must be a scalar.
#'
#' @return a column vector
#' @references
#' \enumerate{
#' Ulric Lund, Claudio Agostinelli, et al's  (2017). R package 'circular':
#' Circular Statistics (version 0.4-91).
#' \url{https://r-forge.r-project.org/projects/circular/}
#' }
#' @examples
#' n  <- 1e2
#' mu <- 0
#' k  <- 10
#'
#' \dontrun{
#' vm1 <- circular:::RvonmisesRad(n, mu, k)
#' vm2 <- rvm(n, mu, k)
#' vm3 <- circular:::conversion.circular(circular:::circular(vm1))
#' vm4 <- circular:::conversion.circular(circular:::circular(vm2))
#' plot(vm3)
#' plot(vm4)
#' }
#' @export
rvonmises <- function(n, mu, kappa) {
    .Call('_ggdmc_rvonmises', PACKAGE = 'ggdmc', n, mu, kappa)
}

#' @rdname rvonmises
#' @export
dvonmises <- function(x, mu, kappa) {
    .Call('_ggdmc_dvonmises', PACKAGE = 'ggdmc', x, mu, kappa)
}

#' @rdname rvonmises
#' @export
pvonmises <- function(q, mu, kappa, tol = 1e-20) {
    .Call('_ggdmc_pvonmises', PACKAGE = 'ggdmc', q, mu, kappa, tol)
}

