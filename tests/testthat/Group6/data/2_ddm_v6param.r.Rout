
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # q(save = "no")
> cat("\n\n-------------------- Generate DDM v model --------------------")


-------------------- Generate DDM v model --------------------> rm(list = ls())
> pkg <- c("ddModel", "ggdmcPrior")
> suppressPackageStartupMessages(tmp <- sapply(pkg, require, character.only = TRUE))
> 
> cat("\nWorking directory: ", getwd(), "\n")

Working directory:  /home/yslin/Documents/ggdmc/tests/testthat/Group6/data 
> wkdir <- "~/Documents/ggdmc/tests/testthat/Group6/data/"
> save_path <- paste0(wkdir, "ddm_data2.rda")
> 
> hyper_model <- ggdmcModel::BuildModel(
+     p_map = list(
+         a = "1", v = "S", z = "1", d = "1", sz = "1", sv = "1",
+         t0 = "1", st0 = "1", s = "1", precision = "1"
+     ),
+     match_map = list(M = list(s1 = "r1", s2 = "r2")),
+     factors = list(S = c("s1", "s2")),
+     constants = c(d = 0, s = 1, st0 = 0, sv = 0, precision = 3),
+     accumulators = c("r1", "r2"),
+     type = "hyper",
+     verbose = FALSE
+ )
> 
> model <- ggdmcModel::BuildModel(
+     p_map = list(
+         a = "1", v = "S", z = "1", d = "1", sz = "1", sv = "1",
+         t0 = "1", st0 = "1", s = "1", precision = "1"
+     ),
+     match_map = list(M = list(s1 = "r1", s2 = "r2")),
+     factors = list(S = c("s1", "s2")),
+     constants = c(d = 0, s = 1, st0 = 0, sv = 0, precision = 3),
+     accumulators = c("r1", "r2"),
+     type = "fastdm"
+ )
 parameters (6 total):
a	sz	t0	v.s1	v.s2	z

 cell names (4 total):
s1.r1	s1.r2	s2.r1	s2.r2
> 
> pop_mean <- c(a = 1, sz = 0.25, t0 = 0.15, v.s1 = 2.5, v.s2 = 2.1, z = 0.38)
> pop_scale <- c(a = 0.05, sz = 0.01, t0 = 0.02, v.s1 = .5, v.s2 = 0.25, z = 0.01)
> pop_dist <- ggdmcPrior::BuildPrior(
+     p0    = pop_mean,
+     p1    = pop_scale,
+     lower = c(0, 0, 0, -10, -10, 0),
+     upper = rep(NA, model@npar),
+     dists = rep("tnorm", model@npar),
+     log_p = rep(F, model@npar)
+ )
> 
> 
> # ---------------------------------------
> sub_model <- setDDM(model)
> pop_model <- setDDM(model, population_distribution = pop_dist)
> 
> p_vector <- c(a = 1, sz = 0.25, t0 = 0.15, v.s1 = 2.5, v.s2 = 2.1, z = .38)
> 
> dat <- simulate(sub_model, nsim = 64, parameter_vector = p_vector, n_subject = 1, debug = TRUE)

[n_trial per condition, n_trial]: [16, 64]
Simulation settings:
---------------------
Main seed: 901768
Number of subjects: 1

Seeds for each subject:
  Subject 1: 82390
Set seed to: 82390
st0 = 0 < 1.50017e-08. sv = 0 < 1e-05. sz = 0.25. Selecting f_sz.

Initial search range: t_min = -1, t_max = 1
Point 0: t = -1, F = 0.000138724
Point 1: t = -0.999, F = 0.000139856
Point 2: t = -0.998, F = 0.000140995
Point 3: t = -0.997, F = 0.000142143
Point 4: t = -0.996, F = 0.0001433
Point 1996: t = 0.996, F = 0.998252
Point 1997: t = 0.997, F = 0.998266
Point 1998: t = 0.998, F = 0.99828
Point 1999: t = 0.999, F = 0.998294
Point 2000: t = 1, F = 0.998308
Use the parameter at the first response to simulate
Current and previous conditions: s1, s1
Current node/accumulator is: r2, which is not the node 1, r1. skip

st0 = 0 < 1.50017e-08. sv = 0 < 1e-05. sz = 0.25. Selecting f_sz.

Initial search range: t_min = -1, t_max = 1
Upper search: t = 1.5, density = 0.999909
Point 0: t = -1, F = 0.000403155
Point 1: t = -0.999, F = 0.00040606
Point 2: t = -0.998, F = 0.000408985
Point 3: t = -0.997, F = 0.00041193
Point 4: t = -0.996, F = 0.000414893
Point 2496: t = 1.496, F = 0.999906
Point 2497: t = 1.497, F = 0.999907
Point 2498: t = 1.498, F = 0.999908
Point 2499: t = 1.499, F = 0.999908
Point 2500: t = 1.5, F = 0.999909
Use the parameter at the first response to simulate
Current and previous conditions: s2, s2
Current node/accumulator is: r2, which is not the node 1, r1. skip

Processing time (process model): 0.035 secs.
> hdat <- simulate(pop_model, nsim = 64, n_subject = 32)
No seed provided. Using R-generated seed: 901768

[n_trial per condition, n_trial]: [16, 64]
Simulation settings:
---------------------
Main seed: 901768
Number of subjects: 32

Seeds for the first 5 subjects:
  Subject 1: 82390
  Subject 2: 427031
  Subject 3: 790329
  Subject 4: 120213
  Subject 5: 838399
Processing time (process model): 0.898 secs.
> 
> 
> sub_dmis <- ggdmcModel::BuildDMI(dat, model)
> pop_dmis <- ggdmcModel::BuildDMI(hdat, model)
> hyper_dmi <- ggdmcModel::BuildDMI(hdat, hyper_model)
> 
> options(digits = 3)
> cat("Accuracy: \n")
Accuracy: 
> c(mean(dat$C), mean(hdat$C))
[1] 0.859 0.802
> 
> ps <- attr(hdat, "parameters")
> true_mean <- pop_mean[sort(names(pop_mean))]
> true_scale <- pop_scale[sort(names(pop_scale))]
> names(true_mean) <- paste0("loc_", names(true_mean))
> names(true_scale) <- paste0("sca_", names(true_scale))
> true_vector <- c(true_mean, true_scale)
> 
> 
> # Generate subj samples -------------------------
> p0 <- rep(0, model@npar)
> names(p0) <- model@pnames
> p_prior <- ggdmcPrior::BuildPrior(
+     p0 = p0,
+     p1 = rep(10, model@npar),
+     lower = rep(NA, model@npar),
+     upper = rep(NA, model@npar),
+     dist = rep("unif", model@npar),
+     log_p = rep(TRUE, model@npar)
+ )
> 
> 
> sub_priors <- set_priors(p_prior = p_prior)
> 
> nmc <- 500
> sub_theta_input <- ggdmc::setThetaInput(nmc = nmc, pnames = model@pnames)
Using 18 chains is to optimise the model
> sub_samples <- ggdmc::initialise_theta(sub_theta_input, sub_priors, sub_dmis[[1]], seed = 846671, verbose = F)
> 
> save(hyper_model, model, hdat, dat, p_vector, pop_mean, pop_scale, true_vector, ps,
+     sub_dmis, pop_dmis, hyper_dmi, sub_priors, sub_samples, sub_theta_input,
+     file = save_path
+ )
> 
> 
> # Generate pop samples -------------------------
> p0 <- runif(model@npar)
> names(p0) <- model@pnames
> model_likelihood <- ggdmcPrior::BuildPrior(
+     p0 = p0,
+     p1 = rep(10, model@npar),
+     lower = rep(0, model@npar),
+     upper = rep(NA, model@npar),
+     dist = rep("tnorm", model@npar),
+     log_p = rep(TRUE, model@npar)
+ )
> 
> 
> # Prior log likelihoods
> p0 <- rep(0, model@npar)
> names(p0) <- model@pnames
> l_prior <- ggdmcPrior::BuildPrior(
+     p0 = p0,
+     p1 = rep(10, model@npar),
+     lower = rep(0, model@npar),
+     upper = rep(NA, model@npar),
+     dist = rep("unif", model@npar),
+     log_p = rep(TRUE, model@npar)
+ )
> 
> 
> s_prior <- ggdmcPrior::BuildPrior(
+     p0 = p0,
+     p1 = rep(10, model@npar),
+     lower = rep(NA, model@npar),
+     upper = rep(NA, model@npar),
+     dist = rep("unif", model@npar),
+     log_p = rep(TRUE, model@npar)
+ )
> 
> pop_priors <- ggdmcPrior::set_priors(p_prior = model_likelihood, l_prior = l_prior, s_prior = s_prior)
> pop_theta_input <- ggdmc::setThetaInput(nmc = nmc, pnames = pop_priors@pnames)
Using 36 chains is to optimise the model
> 
> pop_samples <- ggdmc::initialise_phi(pop_theta_input, pop_priors, pop_dmis, seed = 846671, verbose = FALSE)
> 
> save(hyper_model, model, hdat, dat, p_vector, pop_mean, pop_scale, true_vector, ps,
+     sub_dmis, pop_dmis, hyper_dmi,
+     sub_priors, sub_samples, sub_theta_input,
+     pop_priors, pop_samples, pop_theta_input,
+     file = save_path
+ )
> 
> proc.time()
   user  system elapsed 
  1.922   0.108   2.023 
